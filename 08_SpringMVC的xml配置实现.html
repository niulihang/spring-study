<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>SpringMVC&#x7684;xml&#x914d;&#x7f6e;&#x5b9e;&#x73b0;</title>
        <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
        
    </head>
    <body class="vscode-body vscode-light">
        <h1 id="springmvc的xml配置实现">SpringMVC的xml配置实现</h1>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-14-00-56-04-image.png" alt="图 0"></p>
<ul>
<li><a href="#springmvc%E7%9A%84xml%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0">SpringMVC的xml配置实现</a>
<ul>
<li><a href="#1-springmvc%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8">1. SpringMVC快速使用</a></li>
<li><a href="#2-controller%E4%B8%AD%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84bean">2. Controller中访问容器中的Bean</a></li>
<li><a href="#3-springmvc%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6">3. SpringMVC关键组件</a></li>
<li><a href="#4-springmvc%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86">4. SpringMVC的请求处理</a></li>
<li><a href="#5-%E8%8E%B7%E5%8F%96get%E8%AF%B7%E6%B1%82%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9">5. 获取Get请求的键值对</a></li>
<li><a href="#6-post%E8%AF%B7%E6%B1%82">6. Post请求</a></li>
<li><a href="#7-restful%E9%A3%8E%E6%A0%BC%E6%95%B0%E6%8D%AE">7. Restful风格数据</a></li>
<li><a href="#8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">8. 文件上传</a></li>
<li><a href="#9-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%A4%B4">9. 处理请求头</a></li>
<li><a href="#10-%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90">10. 访问静态资源</a></li>
<li><a href="#11-%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8mvcannotation-driven%E6%A0%87%E7%AD%BE">11. 注解驱动&lt;mvc:annotation-driven&gt;标签</a></li>
<li><a href="#12-%E5%93%8D%E5%BA%94%E7%9A%84%E5%A4%84%E7%90%86">12. 响应的处理</a>
<ul>
<li><a href="#121-%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F">12.1 同步方式</a></li>
<li><a href="#122-%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F">12.2 异步方式</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-springmvc快速使用">1. SpringMVC快速使用</h2>
<ul>
<li>
<p>导入spring-mvc坐标</p>
</li>
<li>
<p>配置前端控制器DispatcherServlet</p>
</li>
</ul>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>

<span class="hljs-comment">&lt;!--配置DispatcherServlet--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>
    <span class="hljs-comment">&lt;!--SpringMVC容器配置文件--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
</code></pre>
<ul>
<li>编写Controller，配置映射路径，并交给SpringMVC容器管理</li>
</ul>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickController</span> {

    <span class="hljs-meta">@RequestMapping(&quot;/show&quot;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">&quot;QuickController show...&quot;</span>);
    }

}
</code></pre>
<h2 id="2-controller中访问容器中的bean">2. Controller中访问容器中的Bean</h2>
<ul>
<li>
<p>建立Spring容器的xml配置（Spring容器与SpringMVC容器不同）</p>
</li>
<li>
<p>配置Service，并注册到Spring容器中</p>
</li>
<li>
<p>在web.xml配置Spring容器</p>
</li>
</ul>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span>
</code></pre>
<ul>
<li>此时，可以在Controller中使用@Autowired注解获取Service的Bean</li>
</ul>
<hr>
<blockquote>
<p>Spring容器和SpringMVC容器
Spring容器是父容器，SpringMVC容器是子容器，子容器可以访问父容器的内容，父容器不能访问子容器的内容。
通过xml配置搭建SpringMVC项目时，需要在web.xml中配置两部分内容，一是<code>ContextLoaderListener</code>，它读取的配置文件是Spring容器的配置文件applicationContext.xml，二是<code>DispatcherServlet</code>，它读取的是spring-mvc.xml。<strong><code>ContextLoaderListener</code>负责创建Spring容器，<code>DispatcherServlet</code>负责创建SpringMVC容器</strong>。
Spring容器负责管理基础的Bean，如dao和service等，SpringMVC容器负责管理Controller和解析器等和web相关的Bean。
如果将相同的Bean在两个容器中都进行配置，那么就会产生两份Bean，造成资源浪费，但并不会对容器的行为产生影响，因为，在Controller层进行Bean的操作，会直接去SpringMVC容器中查找Bean，而在service或dao层进行bean的操作，父容器无法访问子容器，找到的是Spring容器中的Bean。</p>
<p>为什么需要父子容器？
父子容器的主要作用是划分框架边界，实现单一职责，web层用SpringMVC容器管理，service和dao层用Spring容器管理。</p>
</blockquote>
<hr>
<h2 id="3-springmvc关键组件">3. SpringMVC关键组件</h2>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-14-05-25-00-image.png" alt="图 1"></p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-14-05-27-26-image.png" alt="图 2"></p>
<p>但是，这三个组件我们并没有配置，而是通过spring-mvc包中的默认配置执行的，</p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-14-05-38-13-image.png" alt="图 3"></p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-14-05-38-58-image.png" alt="图 4"></p>
<p>在DispatcherServlet中，维护了三个对应的集合，按照配置文件来看，每个组件加载有多个对象</p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-14-05-41-14-image.png" alt="图 5"></p>
<p>实际上，确实是这样的，以handlerMappings为例，此处获取的就是properties文件中配置的三个handlerMapping实现，</p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-14-05-56-50-image.png" alt="图 6"></p>
<p><strong>注意，此时的这三个组件是放在DispatcherServlet中的，而不是Spring容器或者SpringMVC容器中的</strong>，</p>
<p><strong>另外，如果在SpringMVC的配置文件中配置了handlerMapping的实现，那就不会再去加载properties配置的了</strong>。</p>
<h2 id="4-springmvc的请求处理">4. SpringMVC的请求处理</h2>
<p>请求路径可以在Controller的方法上，通过注解RequestMapping配置，除此之外，还有其他注解，</p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-14-06-08-40-image.png" alt="图 7"></p>
<p>如果，RequestMapping放在类上，并且方法上也同时配置了，那么路径应该是两者路径的累加。</p>
<h2 id="5-获取get请求的键值对">5. 获取Get请求的键值对</h2>
<p>请求地址为，</p>
<pre><code class="language-context">http://localhost/param1?username=zhangsan&amp;&amp;age=18
</code></pre>
<p>配置的Controller，</p>
<pre><code class="language-java"><span class="hljs-meta">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParamController</span> {

    <span class="hljs-comment">// http://localhost/param1?username=zhangsan&amp;&amp;age=18</span>
    <span class="hljs-meta">@GetMapping(&quot;/param1&quot;)</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">param1</span><span class="hljs-params">(String username, Integer age)</span> {
        System.out.println(<span class="hljs-string">&quot;username=&quot;</span> + username + <span class="hljs-string">&quot;,age=&quot;</span> + age);
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
    }

}
</code></pre>
<p>请求的参数名应和方法中的参数名相同，如果不同的话，应该如何配置呢？在参数名上，加入@RequestParam注解</p>
<pre><code class="language-java"><span class="hljs-comment">// http://localhost/param1?username=zhangsan&amp;&amp;age=18</span>
<span class="hljs-meta">@GetMapping(&quot;/param1&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param1</span><span class="hljs-params">(
    <span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String name,
    <span class="hljs-meta">@RequestParam(&quot;age&quot;)</span> Integer age
)</span> {
    System.out.println(<span class="hljs-string">&quot;username=&quot;</span> + name + <span class="hljs-string">&quot;,age=&quot;</span> + age);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<p>一对多的键值对，</p>
<pre><code class="language-java"><span class="hljs-comment">// http://localhost:8080/param2?hobby=zp&amp;hobby=pq&amp;hobby=tq</span>
<span class="hljs-meta">@GetMapping(&quot;/param2&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param3</span><span class="hljs-params">(String[] hobby)</span> {
    Arrays.stream(hobby).forEach(System.out::println);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<p>上述代码中，将数组改为集合时，报错：No primary or single unique constructor found for interface java.util.List。此时，需要在集合前加入@RequestParam注解，</p>
<pre><code class="language-java"><span class="hljs-comment">// http://localhost:8080/param2?hobby=zp&amp;hobby=pq&amp;hobby=tq</span>
<span class="hljs-meta">@GetMapping(&quot;/param2&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param3</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;String&gt; hobby)</span> {
<span class="hljs-comment">//        Arrays.stream(hobby).forEach(System.out::println);</span>
   <span class="hljs-keyword">if</span> (hobby != <span class="hljs-literal">null</span>) hobby.forEach(System.out::println);
   <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<p>使用map接收全部参数，</p>
<pre><code class="language-java"><span class="hljs-comment">// http://localhost:8080/param3?username=zhangsan&amp;&amp;age=18</span>
<span class="hljs-meta">@GetMapping(&quot;/param3&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param3</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> Map&lt;String, String&gt; params)</span> {
    System.out.println(params);
    params.forEach((k, v) -&gt; System.out.println(<span class="hljs-string">&quot;k=&quot;</span> + k + <span class="hljs-string">&quot;,v=&quot;</span> + v));
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<p>将接收参数封装为POJO，只要参数名称和POJO的属性名一致，就可以进行自动封装。首先，建立POJO，User和Address，</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> {

    <span class="hljs-keyword">private</span> String username;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> String[] hobbies;
    <span class="hljs-comment">// 这里暂时不用LocalDate，默认情况下，解析参数需要通过反射实例化创建对象，LocalDate没有构造函数，无法反射实例化</span>
    <span class="hljs-keyword">private</span> Date birthday;
    <span class="hljs-keyword">private</span> Address address;

    <span class="hljs-comment">// getter and setter</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> {

    <span class="hljs-keyword">private</span> String city;
    <span class="hljs-keyword">private</span> String area;

    <span class="hljs-comment">// getter and setter</span>
}
</code></pre>
<p>请求地址</p>
<pre><code class="language-context">http://localhost:8080/param4?username=zhangsan&amp;age=18&amp;hobbies=zq&amp;hobbies=pq&amp;birthday=2011/05/06
</code></pre>
<p>要使用包装的POJO，即上述的Address对象，请求地址应为，</p>
<pre><code class="language-context">http://localhost:8080/param4?username=zhangsan&amp;age=18&amp;hobbies=zq&amp;hobbies=pq&amp;birthday=2011/05/06&amp;address.city=china&amp;address.area=shanghai
</code></pre>
<h2 id="6-post请求">6. Post请求</h2>
<p>要接收Post请求，需要在Controller中使用注解@PostMapping。Post请求的参数，存放在请求体中，获取的方法是使用@RequestBody，如下</p>
<pre><code class="language-java"><span class="hljs-comment">// http://localhost:8080/param5</span>
<span class="hljs-meta">@PostMapping(&quot;/param5&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param5</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String body)</span> {
    System.out.println(body);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<p>现在获取的body是Json格式的字符串，要将其转为POJO对象，可以使用Json工具（如Jackson），</p>
<p>坐标引入，</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.14.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<pre><code class="language-java"><span class="hljs-comment">// http://localhost:8080/param6</span>
<span class="hljs-meta">@PostMapping(&quot;/param6&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param6</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String body)</span> <span class="hljs-keyword">throws</span> JsonProcessingException {
    <span class="hljs-comment">// 使用jackson转换json为user对象</span>
    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> objectMapper.readValue(body, User.class);
    System.out.println(user);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<p>上述方法中，手动的将Json字符串转为POJO不太方便，可以通过配置消息转换器解决。</p>
<p>在SpringMVC容器中的配置如下，</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;messageConverters&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>
</code></pre>
<p>代码可以精简为，</p>
<pre><code class="language-java"><span class="hljs-comment">// http://localhost:8080/param7</span>
<span class="hljs-meta">@PostMapping(&quot;/param7&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param7</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> {
    System.out.println(user);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<h2 id="7-restful风格数据">7. Restful风格数据</h2>
<p>Rest（Representational State Transfer）表象化状态转变（表述性状态转变），在2000年提出，基于Http、URI、xml、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构涉及，是Web服务的一种新型网络应用程序的设计风格。</p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-17-18-34-34-image.png" alt="图 4"></p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-17-18-35-35-image.png" alt="图 5"></p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-17-18-48-48-image.png" alt="图 6"></p>
<p>要实现Restful风格的数据接收，代码也需要做些改变，以查询为例，使用注解PathVariable接收参数，</p>
<pre><code class="language-java"><span class="hljs-comment">// http://localhost:8080/param8/100 -&gt;根据id查询</span>
<span class="hljs-meta">@GetMapping</span> (<span class="hljs-string">&quot;/user/{id}&quot;</span>)
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-type">int</span> id)</span> {
    System.out.println(id);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<h2 id="8-文件上传">8. 文件上传</h2>
<p>接收文件上传的数据，上传的表单有一定的要求，</p>
<ul>
<li>表单的提交方式必须是POST</li>
<li>表单的enctype属性必须是multipart/form-data</li>
<li>文件上传项要有name属性</li>
</ul>
<p>另外，SpringMVC接收文件，需要有文件解析器，该配置默认未开启，需要手动在SpringMVC容器中开启，并且，<strong>id必须为multipartResolver</strong>，如下，</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>/&gt;</span>
</code></pre>
<p>该解析器还有其他属性可以配置，</p>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-17-21-16-16-image.png" alt="图 7"></p>
<p>另外，该配置有依赖需要导入，</p>
<pre><code class="language-xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<p>在Controller接收文件时，需要将文件对象定义为MultipartFile，POST方式的参数在请求体中，还需要使用注解RequestBody，</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping(&quot;/param8&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param8</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> MultipartFile myFile)</span> {
    System.out.println(myFile);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<h2 id="9-处理请求头">9. 处理请求头</h2>
<p>获取请求头需要使用注解RequestHeader，可以指定获取头的哪个键值对或者是全部，</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping(&quot;/param9&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param9</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader</span> Map&lt;String, String&gt; headerValues)</span> {
    System.out.println(headerValues);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<p>头部分还有一个重要的信息Cookie，需要使用注解CookieValue获取，</p>
<pre><code class="language-java"><span class="hljs-meta">@PostMapping(&quot;/param10&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">param10</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> {
    System.out.println(cookie);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/index.jsp&quot;</span>;
}
</code></pre>
<h2 id="10-访问静态资源">10. 访问静态资源</h2>
<p>在原始的Web项目中，直接通过<code>http://localhost:8080/index.html</code>可以直接访问静态资源，现在使用SpringMVC后，同样的URL访问失败，报错404。这是因为SpringMVC中的DispatcherServlet使用的URL-PATTERN中使用了<code>/</code>，覆盖了Tomcat中的默认Servlet。</p>
<p>那应该如何访问静态资源呢？</p>
<ul>
<li>方式一，在web.xml中，再次激活DefaultServlet</li>
</ul>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.html<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span>
</code></pre>
<ul>
<li>
<p>方式二，在spring-mvc.xml中配置静态资源映射，使用标签&lt;mvc:resources&gt;，匹配请求路径和资源</p>
</li>
<li>
<p>方式三，在spring-mvc.xml中配置&lt;mvc:default-servlet-handler&gt;，该方式是注册了一个<code>DefaultServletHttpRequestHandler</code>，静态资源的访问都由该处理器处理，开发中使用最多</p>
</li>
</ul>
<p>使用方式二和方式三访问静态资源时，如果没有显示的配置<code>RequestMappingHandlerMapping</code>，则Controller中的地址无法访问。这是因为这些方式向容器中注入了一个HandlerMapping，默认配置的<code>RequestMappingHandlerMapping</code>就不再加载了。如果要同时实现静态资源访问和Controller访问，需要显示的在spring-mvc中声明<code>RequestMappingHandlerMapping</code>的定义。</p>
<h2 id="11-注解驱动mvcannotation-driven标签">11. 注解驱动&lt;mvc:annotation-driven&gt;标签</h2>
<p>根据上述，在spring-mvc.xml中配置了<code>RequestMappingHandlerMapping</code>、<code>RequestMappingHandlerAdapter</code>（用于配置消息转换器），这些内容可以用一个标签代替，即，&lt;mvc:annotation-driven&gt;。</p>
<p>该标签内部会自动注册<code>RequestMappingHandlerMapping</code>和<code>RequestMappingHandlerAdapter</code>，并注入JSON消息转换器等。</p>
<h2 id="12-响应的处理">12. 响应的处理</h2>
<p>响应数据主要分为两部分：</p>
<ul>
<li>传统的同步方式。</li>
<li>前后端分离的异步方式。前端使用Ajax+Restful风格与服务端进行JSON格式为主的数据交互，是目前的主流方式。</li>
</ul>
<h3 id="121-同步方式">12.1 同步方式</h3>
<p>同步方式涉及以下四种形式，</p>
<ul>
<li>转发，使用forward关键字，可省略</li>
<li>重定向，使用redirect关键字</li>
</ul>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-18-11-20-20-image.png" alt="图 1"></p>
<ul>
<li>响应模型数据。SpringMVC中可以使用ModelAndView设置属性值和转发的路径，代替传统的Request域，但是，目前这种方式基本上已经不适用了，</li>
</ul>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping(&quot;/res1&quot;)</span>
<span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">res1</span><span class="hljs-params">(ModelAndView modelAndView)</span> {
    <span class="hljs-comment">// ModelAndView封装模型数据和视图名</span>
    <span class="hljs-comment">// 设置模型数据</span>
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
    user.setUsername(<span class="hljs-string">&quot;Jim&quot;</span>);
    user.setAge(<span class="hljs-number">18</span>);
    modelAndView.addObject(<span class="hljs-string">&quot;user&quot;</span>, user);
    <span class="hljs-comment">// 设置试图名称，在页面中展示数据</span>
    modelAndView.setViewName(<span class="hljs-string">&quot;/index.jsp&quot;</span>);
    <span class="hljs-keyword">return</span> modelAndView;
}
</code></pre>
<ul>
<li>直接回写给客户端。返回的的字符串不是视图名，而是值，需要使用注解ResponseBody</li>
</ul>
<pre><code class="language-java"><span class="hljs-comment">// 直接回写字符串</span>
<span class="hljs-meta">@GetMapping(&quot;/res2&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>  <span class="hljs-comment">// 告诉springmvc返回的字符串不是视图名，是以响应体方式响应数据</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">res2</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world!&quot;</span>;
}
</code></pre>
<h3 id="122-异步方式">12.2 异步方式</h3>
<p><img src="file:///d:\notes\spring basic\imgs\2023-04-18-15-40-40-image.png" alt="图 2"></p>
<pre><code class="language-java"><span class="hljs-meta">@GetMapping(&quot;/ajax/req2&quot;)</span>
<span class="hljs-meta">@ResponseBody</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">req2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException {
    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
    user.setUsername(<span class="hljs-string">&quot;Jim&quot;</span>);
    user.setAge(<span class="hljs-number">18</span>);
    <span class="hljs-comment">// json转换工具</span>
    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();
    <span class="hljs-comment">// 设定json字符串中不包含空值</span>
    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
    <span class="hljs-keyword">return</span> objectMapper.writeValueAsString(user);
}
</code></pre>
<p>其中，JSON转换可以省略，就像之前配置的消息转换器一样，直接返回User对象。</p>
<p>另外，注解ResponseBody可以写在类上，方法上省略，而且，注解ResponseBody和注解Controller可以合并，以符合Restful风格，合并的注解为<strong>RestController</strong>。</p>

        
        
    </body>
    </html>